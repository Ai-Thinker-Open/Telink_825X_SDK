# UART BOOT 简介

## 目的
8258 系列芯片不支持串口烧录，需要额外购买烧录器，要100多RMB。于是开发了串口烧录功能，节省烧录器的钱，有利于推广。

## 原理
bootloader存放在Flash的前16KBytes。上电时这部分代码会检测SWS引脚的高低，根据不同的条件判断是进入烧录模式还是运行模式。

芯片上电后，CPU自动将Flash的前16K数据(即BootLoader)复制到内存中，然后从0地址处才是运行。BootLoader根据SWS引脚的高低判断该进入那种模式。

如果进入烧录模式，将会继续运行bootloader代码，等待用户烧录固件。

如果进入运行模式，将会把应用层代码的Ram code 从Flash的 0x2C000 地址复制到内存0x0中，然后从内存0x0地址启动应用层代码。

## FLASH分布

正常编译的固件数据分布：

|地址|0x0-0x4000|0x4000 - 0x30000|
|----|----------|--------------|
|大小|16KBytes|最大176KBytes|
|内容|Ram Code|非 Ram Code|


加上BootLoader后的Flash分布;

|地址|0x0-0x4000|0x4000 - 0x2C000|0x2C000 - 0x30000|
|----|----------|--------------|-------------|
|大小|16KBytes  |最大160KBytes  |16KBytes|
|内容|BootLoader|非 Ram Code   |Ram Code|

由上表可知，用户编译的固件在Flash中被拆分成了两部分，即将其前16KBytes的内容(Ram Code)放到了0x2C000的位置，非 Ram Code 存放地址不变。

## 注意

BootLoader中用于复制用户程序的代码占据了32Bytes的内存，0x843fe0 - 0x844000 这部分内存将不可用。

## 指令格式

|第一字节|第二三字节|余下字节|
|-------|---------|--------|
|CMD|参数长度|参数|

|指令|含义|参数|示例|备注|
|----|----|---|---|----|
|0x00|读取版本号|无|00 00 00|
|0x01|写Flash|地址，校验及数据|01 01 05 00 00 40 00 xx [256 data]|向0x4000地址写256字节数据(不擦除)
|0x02|读Flash|地址，长度|02 00 05 00 00 40 00 ff|读取0x4000地址的255个字节的数据|
|0x03|擦除Flash|地址，擦除扇区数|03 00 05 00 00 80 00 24| 擦除0x8000起始的0x24个扇区的数据)
